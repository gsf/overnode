#!/usr/bin/env node
// Overnode executable, for spawning and watching over processes
// 
// See etc/overnode for example config file

var fs = require('fs');
var spawn = require('child_process').spawn;
var util = require('util');

var configFile = process.argv[2] || '/usr/local/etc/overnode';
var children = JSON.parse(fs.readFileSync(configFile));
//console.log(util.inspect(children));

var names = Object.keys(children);
names.forEach(function(name) {
  var child = children[name];
  if (child.stdout) 
    child.stdoutStream = fs.createWriteStream(child.stdout, {flags: 'a'});
  if (child.stderr) 
    child.stderrStream = fs.createWriteStream(child.stderr, {flags: 'a'});
  spawnInstance(child);
});

util.log('Overnode spawned '+names.length+' processes');

// Kill children on stop
process.on('SIGTERM', function() {
  names.forEach(function(name) {
    var child = children[name];
    child.instance.forceStop = true;
    child.instance.kill();
    if (child.stdoutStream) child.stdoutStream.end();
    if (child.stderrStream) child.stderrStream.end();
  });
  // XXX will this help with hanging process?
  process.exit();
});

function spawnInstance(child) {
  var args = child.args || [];
  var fullCommand = child.command+' '+args.join(' ');
  util.log('Spawning child: '+fullCommand);
  child.instance = spawn(child.command, args);
  child.instance.ctime = Date.now();
  if (child.watch) {
    fs.watch(child.watch, function(event) {
      util.log('File changed: '+child.watch);
      child.instance.kill();
    });
  }
  if (child.stdoutStream) {
    child.instance.stdout.on('data', function(data) {
      child.stdoutStream.write(data);
    });
  }
  if (child.stderrStream) {
    child.instance.stderr.on('data', function(data) {
      child.stderrStream.write(data);
    });
  }
  // Respawn on exit if not forceStop
  child.instance.on('exit', function() {
    util.log('Child killed: '+fullCommand);
    if (!child.instance.forceStop && Date.now() - child.instance.ctime > 1000) {
      spawnInstance(child);
    }
  });
}
